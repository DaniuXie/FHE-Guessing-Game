// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "fhevm/lib/TFHE.sol";

/**
 * @title GuessGame
 * @notice 简化版机密数字猜谜游戏
 * @dev 使用FHEVM进行加密存储，简化版本不使用Gateway
 */
contract GuessGame {
    // ============ 类型定义 ============
    
    enum GameStatus {
        ACTIVE,      // 游戏进行中
        ENDED        // 游戏已结束
    }
    
    struct Game {
        uint256 gameId;
        address owner;
        euint32 targetNumber;       // 加密的目标数字
        uint256 entryFee;
        uint256 prizePool;
        address[] players;
        mapping(address => euint32) guesses;
        mapping(address => bool) hasGuessed;
        GameStatus status;
        address winner;
        uint256 createdAt;
    }
    
    // ============ 状态变量 ============
    
    uint256 public gameCounter;
    mapping(uint256 => Game) public games;
    
    // ============ 事件 ============
    
    event GameCreated(
        uint256 indexed gameId,
        address indexed owner,
        uint256 entryFee,
        uint256 timestamp
    );
    
    event PlayerJoined(
        uint256 indexed gameId,
        address indexed player,
        uint256 prizePool,
        uint256 timestamp
    );
    
    event GameEnded(
        uint256 indexed gameId,
        address indexed winner,
        uint256 prize,
        uint256 timestamp
    );
    
    // ============ 修饰符 ============
    
    modifier onlyGameOwner(uint256 gameId) {
        require(games[gameId].owner == msg.sender, "Only game owner");
        _;
    }
    
    modifier gameExists(uint256 gameId) {
        require(gameId > 0 && gameId <= gameCounter, "Game does not exist");
        _;
    }
    
    modifier gameIsActive(uint256 gameId) {
        require(games[gameId].status == GameStatus.ACTIVE, "Game is not active");
        _;
    }
    
    // ============ 主要函数 ============
    
    /**
     * @notice 创建新游戏
     * @param encryptedTarget 加密的目标数字
     * @param entryFee 入场费
     */
    function createGame(
        bytes calldata encryptedTarget,
        uint256 entryFee
    ) external returns (uint256) {
        require(entryFee > 0, "Entry fee must be greater than 0");
        
        gameCounter++;
        uint256 newGameId = gameCounter;
        
        Game storage newGame = games[newGameId];
        newGame.gameId = newGameId;
        newGame.owner = msg.sender;
        newGame.entryFee = entryFee;
        newGame.status = GameStatus.ACTIVE;
        newGame.createdAt = block.timestamp;
        
        // 导入加密的目标数字
        newGame.targetNumber = TFHE.asEuint32(encryptedTarget);
        
        emit GameCreated(newGameId, msg.sender, entryFee, block.timestamp);
        
        return newGameId;
    }
    
    /**
     * @notice 加入游戏并提交猜测
     * @param gameId 游戏ID
     * @param encryptedGuess 加密的猜测
     */
    function joinGame(
        uint256 gameId,
        bytes calldata encryptedGuess
    ) external payable gameExists(gameId) gameIsActive(gameId) {
        Game storage game = games[gameId];
        
        require(!game.hasGuessed[msg.sender], "Already guessed");
        require(msg.value == game.entryFee, "Incorrect entry fee");
        require(msg.sender != game.owner, "Owner cannot join");
        
        // 导入加密的猜测
        euint32 guess = TFHE.asEuint32(encryptedGuess);
        
        game.guesses[msg.sender] = guess;
        game.hasGuessed[msg.sender] = true;
        game.players.push(msg.sender);
        game.prizePool += msg.value;
        
        emit PlayerJoined(gameId, msg.sender, game.prizePool, block.timestamp);
    }
    
    /**
     * @notice 结束游戏（简化版：房主手动指定获胜者）
     * @param gameId 游戏ID
     * @param winnerAddress 获胜者地址
     */
    function endGame(uint256 gameId, address winnerAddress) 
        external 
        gameExists(gameId) 
        gameIsActive(gameId) 
        onlyGameOwner(gameId) 
    {
        Game storage game = games[gameId];
        require(game.players.length > 0, "No players");
        require(game.hasGuessed[winnerAddress], "Winner must be a player");
        
        game.status = GameStatus.ENDED;
        game.winner = winnerAddress;
        
        uint256 prize = game.prizePool;
        
        // 转账奖池给获胜者
        (bool success, ) = winnerAddress.call{value: prize}("");
        require(success, "Prize transfer failed");
        
        emit GameEnded(gameId, winnerAddress, prize, block.timestamp);
    }
    
    // ============ 查询函数 ============
    
    /**
     * @notice 获取游戏信息
     */
    function getGameInfo(uint256 gameId) 
        external 
        view 
        gameExists(gameId) 
        returns (
            address owner,
            uint256 entryFee,
            uint256 prizePool,
            uint256 playerCount,
            GameStatus status,
            address winner,
            uint256 createdAt
        ) 
    {
        Game storage game = games[gameId];
        return (
            game.owner,
            game.entryFee,
            game.prizePool,
            game.players.length,
            game.status,
            game.winner,
            game.createdAt
        );
    }
    
    /**
     * @notice 获取玩家列表
     */
    function getPlayers(uint256 gameId) 
        external 
        view 
        gameExists(gameId) 
        returns (address[] memory) 
    {
        return games[gameId].players;
    }
    
    /**
     * @notice 检查是否已猜测
     */
    function hasPlayerGuessed(uint256 gameId, address player) 
        external 
        view 
        gameExists(gameId) 
        returns (bool) 
    {
        return games[gameId].hasGuessed[player];
    }
    
    /**
     * @notice 获取总游戏数
     */
    function getTotalGames() external view returns (uint256) {
        return gameCounter;
    }
}

